<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!-- Slide meta data, remove/edit as you see fit -->
    <title>RSpec</title>
    <meta name="author" content="Kerry Buckley" />
    <meta name="email" content="kerry.buckley@gmail.com" />
    <meta name="date" content="2011-01-04" />
    <meta name="venue" content="Ipswich Ruby User Group" />
    <!-- Slippy core file and dependencies -->
    <script type="text/javascript" src="jquery-1.4.2.min.js"></script>
    <script type="text/javascript" src="jquery.history.js"></script>
    <script type="text/javascript" src="kerryb.js"></script>
    <script type="text/javascript" src="analytics.js"></script>
    <script type="text/javascript" src="slippy-0.9.0.js"></script>
    <!-- Slippy structural styles -->
    <link type="text/css" rel="stylesheet" href="slippy-0.9.0.css"/>
    <!-- Slippy theme -->
    <link type="text/css" rel="stylesheet" href="slippy-kerryb.css"/>
    <!-- Syntax highlighting -->
    <script type="text/javascript" src="highlighter/shCore.js"></script>
    <script type="text/javascript" src="highlighter/shBrushBash.js"></script>
    <script type="text/javascript" src="highlighter/shBrushRuby.js"></script>
    <link type="text/css" rel="stylesheet" href="highlighter/shCore.css"/>
    <link type="text/css" rel="stylesheet" href="highlighter/shThemeEclipse.css"/>
    <!-- Slippy init code -->
    <script type="text/javascript">
      $(function() {
          $(".slide").slippy({
          });
          SyntaxHighlighter.all();
          });
    </script>
  </head>
  <body>
    <div class="slide">
      <div class="vcenter">
        <h1>RSpec</h1>
        <h2 class="center">Kerry Buckley<br />IPRUG, 4 January 2011</h2>
      </div>
    </div>

    <div class="slide">
      <h1>Why RSpec?</h1>
    </div>

    <div class="slide">
      <h1>Why RSpec?</h1>
      <h2>Clear, concise and readable</h2>
      <div class="comparison">
        <div class="left">
          <pre class="ruby">
            class StackTest < Test::Unit
              def setup
                @stack = Stack.new
              end

              def test_new_is_empty
                assert_equal true,
                  @stack.empty?
              end

              def test_new_has_size_0
                assert_equal 0,
                  @stack.size
              end
            end
          </pre>
        </div>
        <div class="middle">
          <p>vs</p>
        </div>
        <div class="right">
          <pre class="ruby">
            describe Stack do
              context "when new" do
                it { should be_empty }
                it { should have(0).items }
              end
            end
          </pre>
        </div>
      </div>
    </div>

    <div class="slide">
      <h1>Why RSpec?</h1>
      <h2>Documentation</h2>
      <div class="vcenter">
        <pre>
          Stack
            when new
              <span style="color:green">should be empty</span>
              <span style="color:green">should have 0 items</span>

          Finished in 0.00089 seconds
          <span style="color:green">2 examples, 0 failures</span>
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Gems</h1>
      <div class="vcenter">
        <ul>
          <li>rspec</li>
          <li>rspec-core</li>
          <li>rspec-expectations</li>
          <li>rspec-mocks</li>
          <li>rspec-rails</li>
        </ul>
      </div>
    </div>

    <div class="slide">
      <h1>Basics</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Rain" do
            it "is wet" do
              ...
            end
          end
        </pre>
        <p><code>specify</code> can also be used in place of <code>it</code>.</p>
      </div>
    </div>

    <div class="slide">
      <h1>Contexts</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Rain" do
            context "in the summer" do
              it "is refreshing" do
                ...
              end
            end

            context "in the winter" do
              it "is unpleasant" do
                ...
              end
            end
          end
        </pre>
        <p><code>context</code> is an alias for <code>describe</code>.</p>
        <p>Use whichever is most appropriate.</p>
      </div>
    </div>

    <div class="slide">
      <h1>Describing methods</h1>
      <pre class="ruby">
        describe MyClass do
          describe ".class_method" do
            ...
          end

          describe "#instance_method" do
            ...
          end
        end
      </pre>
      <hr />
      <p>Documentation output:</p>
      <pre>
        Myclass.class_method
          ...
        Myclass#instance_method
          ...
      </pre>
    </div>

    <div class="slide">
      <h1>Running</h1>
      <div class="vcenter">
        <ul>
          <li>[bundle exec] rspec</li>
          <li>rake</li>
          <li>autotest</li>
          <li>spork</li>
        </ul>
      </div>
    </div>

    <div class="slide">
      <h1>Formatters</h1>
      <h2>progress (default)</h2>
      <div class="vcenter">
        <pre>
          $ rspec --colour spec/
          <span style="color:green">..</span>

          Finished in 0.00089 seconds
          <span style="color:green">2 examples, 0 failures</span>
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>A digression</h1>
      <h2>Configuration file</h2>
      <div class="vcenter">
        <p>We don&rsquo;t want to type <code>--colour</code> every time!</p>
        <p>Put common options in <code>.rspec</code> in the project root.</p>
      </div>
    </div>

    <div class="slide">
      <h1>Formatters</h1>
      <h2>documentation</h2>
      <div class="vcenter">
        <pre>
          $ rspec -f doc spec/

          Stack
            when new
              <span style="color:green">should be empty</span>
              <span style="color:green">should have 0 items</span>

          Finished in 0.00089 seconds
          <span style="color:green">2 examples, 0 failures</span>
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Formatters</h1>
      <h2>html</h2>
      <img src="images/html_output.png" alt="HTML output" />
    </div>

    <div class="slide">
      <h1>Formatters</h1>
      <h2>Fuubar</h2>
      <div class="vcenter">
        <p>Fuubar is an external formatter (<code>gem in fuubar</code>).</p>
        <pre>
          $ rspec -f Fuubar spec/

            1) Stack after pushing 1 item
               <span style="color:red">Failure/Error: it { should have(1).item }</span>
               <span style="color:red">Expected 1 item, got 0</span>
               <span style="color:grey"># ./spec/stack_spec.rb:12</span>

            <span style="color:red">8/10:      80% |================================    | ETA:  00:00:02</span>
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Formatters</h1>
      <h2>Multiple formatters</h2>
      <div class="vcenter">
        <pre>
          $ rspec -f Fuubar -f html -o specs.html spec/
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Profiling</h1>
      <pre>
        $ rspec --profile spec/
          <span style="color:green">55/55:       100% |====================================| Time: 00:00:00</span>

        Top 10 slowest examples:
          RedRock server allows the port to be overridden
            <span style="color:red">0.10258</span> seconds ./spec/redrock_spec.rb:107
          RedRock supports specification of a response body as an IO object
            <span style="color:red">0.08752</span> seconds ./spec/redrock_spec.rb:336
          RedRock returning a custom response returns the specified headers
            <span style="color:red">0.07319</span> seconds ./spec/redrock_spec.rb:331
          ...
      </pre>
    </div>

    <div class="slide">
      <h1>Pending specs</h1>
      <pre class="ruby">
        describe "Something" do
          it "does something" do
            ...
          end

          it "does something I haven't implemented yet"
        end
      </pre>
      <hr />
      <pre>
        Something
          ...
          <span style="color:#aa0">does something I haven't implemented yet (PENDING: Not Yet Implemented)</span>

        Pending:
          <span style="color:#aa0">Something does something I haven't implemented yet</span>
            <span style="color:grey"># Not Yet Implemented</span>
            <span style="color:grey"># ./spec/something_spec.rb:5</span>

        Finished in 0.00052 seconds
        <span style="color:#aa0">2 examples, 0 failures, 1 pending</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Pending specs</h1>
      <pre class="ruby">
        describe "Something" do
          ...

          it "does something I haven't implemented yet" do
            pending "waiting for inspiration"
            ...
          end
        end
      </pre>
      <hr />
      <pre>
        Something
          ...
          <span style="color:#aa0">does something I haven't implemented yet (PENDING: waiting for inspiration)</span>

        Pending:
          <span style="color:#aa0">Something does something I haven't implemented yet</span>
            <span style="color:grey"># waiting for inspiration</span>
            <span style="color:grey"># ./spec/something_spec.rb:5</span>

        Finished in 0.00078 seconds
        <span style="color:#aa0">2 examples, 0 failures, 1 pending</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Pending specs</h1>
      <pre class="ruby">
        describe "Something" do
          before { pending "Coming soon!" }

          it "does something" do
          end

          it "does something else" do
          end
        end
      </pre>
      <hr />
      <pre>
        Something
          <span style="color:#aa0">does something (PENDING: Coming soon!)</span>
          <span style="color:#aa0">does something else (PENDING: Coming soon!)</span>

        Pending:
          <span style="color:#aa0">Something does something</span>
            <span style="color:grey"># Coming soon!</span>
            <span style="color:grey"># ./spec/something_spec.rb:4</span>
          <span style="color:#aa0">Something does something else</span>
            <span style="color:grey"># Coming soon!</span>
            <span style="color:grey"># ./spec/something_spec.rb:7</span>

        Finished in 0.0114 seconds
        <span style="color:#aa0">2 examples, 0 failures, 2 pending</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Running one spec</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Something" do
            it "does stuff" do ...

            it "does other stuff" do ...

            it "does one more thing" do ...
          end
        </pre>
        <hr />
        <pre>
          $ rspec -f doc spec/something_spec.rb:5
          Run filtered using {:line_number=>5}

          Something
            <span style="color:green">does other stuff</span>

          Finished in 0.00036 seconds
          <span style="color:green">1 example, 0 failures</span>
        </pre>
      </div>
    </div>


    <div class="slide">
      <h1>Filtering by tag</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Something" do
            it "does stuff" do
              ...
            end

            it "does the thing I'm working on", :current =&gt; true do
              ...
            end
          end
        </pre>
        <hr />
        <p>Run only specs tagged &lsquo;current&rsquo;</p>
        <pre>
          rspec --tag focus ...
        </pre>
        <p>Run specs <em>not</em> tagged &lsquo;current&rsquo;</p>
        <pre>
          rspec --tag ~focus ...
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Filtering by tag value</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Something" do
            it "behaves one way in Ruby 1.8", :ruby => "1.8" do
              ...
            end

            it "behaves another way in Ruby 1.9", :ruby => "1.9" do
              ...
            end
          end
        </pre>
        <hr />
        <p>Run 1.8 specs:</p>
        <pre>
          rspec --tag ruby:1.8
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Implicit filtering</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Something" do
            it "behaves one way in 1.8", if =&gt; { VERSION =~ /^1.8/ } do
              ...
            end

            it "behaves another way in 1.9", if =&gt; { VERSION =~ /^1.9/ } do
              ...
            end
          end
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Filtering by name</h1>
      <pre class="ruby">
        describe "Something" do
          it "does stuff" do ...

          it "does other stuff" do ...

          it "does one more thing" do ...
        end
      </pre>
      <hr />
      <p>Select specs using a regular expression:</p>
      <pre>
        $ rspec -e stuff spec/something_spec.rb
        Run filtered using {:full_description=&gt;/(?-mix:stuff)/}

        Something
          <span style="color:green">does stuff</span>
          <span style="color:green">does other stuff</span>

        Finished in 0.00101 seconds
        <span style="color:green">2 examples, 0 failures</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Setup and teardown</h1>
      <div class="vcenter">
        <pre class="ruby">
          describe "Something" do
            before :all do
              # per-context setup
            end

            before do
              # per-example setup
            end

            after do
              # per-example teardown
            end

            after :all do
              # per-context teardown
            end
          end
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Expectations</h1>
      <div class="vcenter">
        <p>RSpec adds <code>should</code> and <code>should_not</code> to all objects.</p>
        <pre class="ruby">
          (2 + 2).should == 4

          "foo".should_not == "bar"

          value.should be_true
        </pre>
        <p>The <code>==</code> and <code>be_true</code> are <em>matchers</em>.</p>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Equality</h2>
      <div class="vcenter">
        <pre class="ruby">
          a.should equal(b) # both pass if a.equal? b
          a.should be(b)    #

          a.should eql(b)   # passes if a.eql? b

          a.should == b     # both pass if a == b
          a.should eq(b)    #
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Floating point</h2>
      <div class="vcenter">
        <pre class="ruby">
          Math::PI.should be_within(0.01).of(22.0/7)
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>True or false</h2>
      <div class="vcenter">
        <pre class="ruby">
          obj.should be_true  # passes if obj is truthy (not nil or false)
          obj.should be_false # passes if obj is falsy (nil or false)
          obj.should be_nil   # passes if obj is nil
          obj.should be       # passes if obj is not nil
        </pre>
      <p><code>should be</code> is preferred to <code>should_not be_nil</code>.</p>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Operators</h2>
      <div class="vcenter">
        <pre class="ruby">
          7.should == 7
          [1, 2, 3].should == [1, 2, 3]
          "this is a string".should =~ /^this/
          "this is a string".should_not =~ /^that/
          String.should === "this is a string"
        </pre>
        <p>Comparison operators work with the "be" matcher:</p>
        <pre class="ruby">
          37.should be < 100
          37.should be <= 38
          37.should be >= 2
          37.should be > 7
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Collections</h2>
      <pre class="ruby">
        # These two are identical:
        [1, 2, 3].should have(3).items
        [1, 2, 3].should have_exactly(3).items

        [1, 2, 3].should have_at_least(2).items
        [1, 2, 3].should have_at_most(4).items

        #Â "items" is just syntactic sugar:
        [1, 2, 3].should have(3).numbers

        [1, 2, 3].should include(2)
        [1, 2, 3].should include(1, 2)
        {:a =&gt; 1, :b =&gt; 2}.should include(:a =&gt; 1)

        [1, 2, 3].should =~ [2, 3, 1]
        [:a, :c, :b].should_not =~ [:a, :c]
      </pre>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Strings</h2>
      <div class="vcenter">
        <pre class="ruby">
          "This is a string".should include "str"

          # These two are identical:
          "This is a string".should =~ /^This/
          "This is a string".should match(/^This/)
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Another digression</h1>
      <h2>Failure messages</h2>
      <div class="vcenter">
      <p>The default messages are usually pretty good:</p>
        <pre class="ruby">
          (2 + 2).should == 5
          [1, 2, 3].should =~ [4, 3, 2]
        </pre>
        <hr />
        <pre>
          <span style="color:red">Failure/Error: (2 + 2).should == 5
            expected: 5
                 got: 4 (using ==)

          Failure/Error: [1, 2, 3].should =~ [4, 3, 2]
            expected collection contained:  [2, 3, 4]
            actual collection contained:    [1, 2, 3]
            the missing elements were:      [4]
            the extra elements were:        [1]</span>
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Another digression</h1>
      <h2>Failure messages</h2>
      <div class="vcenter">
      <p>&hellip;but you can use a custom message if you like<sup>*</sup>:</p>
        <pre class="ruby">
          it "includes 3" do
            [1, 2, 3].should include(3), "Oh noes! No three!"
          end
        </pre>
        <hr />
        <pre>
          1) Something includes 3
             <span style="color:red">Failure/Error: [1, 2, 4].should include(3), "Oh noes! No three!"
               Oh noes! No three!</span>
        </pre>
        <p><sup>*</sup>except with operator matchers (<code>==</code> etc).</p>
      </div>
    </div>

    <div class="slide">
      <h1>Back to built-in matchers</h1>
      <h2>Predicates</h2>
      <div class="comparison">
        <div class="left">
          <pre class="ruby">
            [].empty?.should be_true
            42.even?.should be_true
            123.multiple_of?(5).
              should be_false

            {:a =&gt; 1, :b =&gt; 2}.has_key?(:a).
              should be_true
          </pre>
        </div>
        <div class="middle">
          <p>&#10151;</p>
        </div>
        <div class="right">
          <pre class="ruby">
            [].should be_empty
            42.should be_even
            123.should_not be_multiple_of(5)


            {:a =&gt; 1, :b =&gt; 2}.
              should have_key(:a)
          </pre>
        </div>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Classes</h2>
      <div class="vcenter">
        <pre class="ruby">
          "foo".should be_an_instance_of(String)     # Exact class
          "foo".should_not be_an_instance_of(Object) #

          "foo".should be_a_kind_of(Object)          # Match subclasses
          "foo".should be_an(Object)                 #

          "foo".should respond_to(:upcase)
          "foo".should respond_to(:upcase, :downcase)
          "foo".should respond_to(:upcase).with(0).arguments
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Changing values</h2>
      <div class="vcenter">
        <pre class="ruby">
          expect{ array &lt;&lt; 42 }.to change{ array.size }.from(0).to(1)

          expect{ array &lt;&lt; 42 }.to change{ array.size }.by(1)
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Raising and throwing</h2>
      <div class="vcenter">
        <pre class="ruby">
          expect { 4/2 }.to_not raise_error
          expect { 4/0 }.to raise_error
          expect { 4/0 }.to raise_error(ZeroDivisionError)
          expect { 4/0 }.to raise_error(ZeroDivisionError, "divided by 0")

          expect { throw :foo }.to throw_symbol
          expect { throw :foo }.to throw_symbol(:foo)
          expect { throw :foo, 7 }.to throw_symbol(:foo, 7)
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Exist</h2>
      <div class="vcenter">
        <pre class="ruby">
          obj.should exist # passes if obj.exist? returns true
        </pre>
        <p>This is the only use case I could think of:</p>
        <pre class="ruby">
          Pathname("/etc/passwd").should exist
        </pre>
      </div>
    </div>

    <div class="slide">
      <h1>Built-in matchers</h1>
      <h2>Arbitrary blocks</h2>
      <div class="vcenter">
        <pre class="ruby">
          10.should satisfy { |v| v % 5 == 0 }
        </pre>
        <p>Not really recommended, because of the unfriendly failure message:</p>
        <pre>
          <span style="color:red">Failure/Error: 11.should satisfy { |v| v % 5 == 0 }</span>
            <span style="color:red">expected 11 to satisfy block</span>
        </pre>
        <p>Which brings us to&hellip;</p>
      </div>
    </div>

    <div class="slide">
      <h1>Custom matchers</h1>
      <pre class="ruby">
        RSpec::Matchers.define :be_a_multiple_of do |expected|
          match do |actual|
            actual % expected == 0
          end
        end

        describe 10 do
          it { should be_a_multiple_of(5) }
        end
      </pre>
      <hr />
      <pre>
        10
          <span style="color:green">should be a multiple of 5</span>

        Finished in 0.04768 seconds
        <span style="color:green">1 example, 0 failures</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Hang on a minute&hellip;</h1>
      <pre class="ruby">
        RSpec::Matchers.define :be_a_multiple_of do |expected|
          match do |actual|
            actual % expected == 0
          end
        end

        describe 10 do
          it { should be_a_multiple_of(5) }
        end
      </pre>
      <hr />
      <pre>
        10
          <span style="color:green">should be a multiple of 5</span>

        Finished in 0.04768 seconds
        <span style="color:green">1 example, 0 failures</span>
      </pre>
      <p>Firstly, note how a description has been automatically generated for us.</p>
      <p>But what are we calling <code>should</code> on?</p>
    </div>

    <div class="slide">
      <h1>Implicit subject</h1>
      <p>The argument to <code>describe</code> becomes the subject:</p>
      <pre class="ruby">
        describe 42 do
          it { should be_even }
          it { should_not be_zero }
        end
      </pre>
      <p>If it&rsquo;s a class, the subject is a new instance:</p>
      <pre class="ruby">
        describe Array do
          it { should be_empty }
          it { should have(0).items }
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Implicit subject</h1>
      <p>Access attributes of the subject with <code>its</code>:</p>
      <pre class="ruby">
        describe [1, 2, 3, 3] do
          its(:size) { should == 4 }
          its("uniq.size") { should == 3 }
        end
      </pre>
      <hr />
      <pre>
        1233
          size
            <span style="color:green">should == 4</span>
          uniq.size
            <span style="color:green">should == 3</span>

        Finished in 0.00279 seconds
        <span style="color:green">2 examples, 0 failures</span>
      </pre>
      <p>That description (from <code>to_s</code>) could be better...</p>
    </div>

    <div class="slide">
      <h1>Explicit subject</h1>
      <p>You can set the subject explicitly using a block:</p>
      <pre class="ruby">
        describe "An array containing 1, 2, 3, 3" do
          subject { [1, 2, 3, 3] }

          its(:size) { should == 4 }
        end
      </pre>
      <p>And access it in examples as <code>subject</code>:</p>
      <pre class="ruby">
        describe Array do
          it "is empty" do
            subject.should be_empty
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Custom matchers</h1>
      <p>You can override the description and failure messages:</p>
      <pre class="ruby">
        RSpec::Matchers.define :be_a_multiple_of do |expected|
          match do |actual|
            actual % expected == 0
          end

          failure_message_for_should do |actual|
            "expected that #{actual} would be a multiple of #{expected}"
          end

          failure_message_for_should_not do |actual|
            "expected that #{actual} would not be a multiple of #{expected}"
          end

          description do
            "be multiple of #{expected}"
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Custom matchers</h1>
      <p>Not all matchers take an argument:</p>
      <pre class="ruby">
        RSpec::Matchers.define :be_a_multiple_of_3 do
          match do |number|
            number % 3 == 0
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Shoulda matchers</h1>
      <p><a href="https://github.com/thoughtbot/shoulda">Shoulda</a> provides a whole bunch of Rails matchers, including:</p>
      <pre class="ruby">
        it { should render_template(:show) }
        it { should assign_to(:user).with(@user) }
        it { should redirect_to(users_path)  }
        it { should render_with_layout(:special) }
        it { should respond_with(:success)  }
        it { should route(:get, "/posts/new").to(:action =&gt; :new) }
        it { should set_the_flash.to(/created/i) }

        it { should validate_presence_of(:name) }
        it { should_not allow_mass_assignment_of(:password) }
        it { should have_one(:profile) }
        it { should have_db_column(:salary).of_type(:decimal) }
      </pre>
    </div>

    <div class="slide">
      <h1>Speaking of shoulda&hellip;</h1>
      <blockquote>Shoulda is focusing on the RSpec/Shoulda combination and will
        primarily support that combination of tools, moving away from
        Test::Unit.</blockquote>
      <p><em><a href="http://robots.thoughtbot.com/post/701863189/shoulda-rails3-and-beyond">Thoughtbot blog</a>, June 2010</em></p>
    </div>

    <div class="slide">
      <h1>Let there be let</h1>
      <p>These examples have some duplication&hellip;</p>
      <pre class="ruby">
        describe BowlingGame do
          it "scores all gutters with 0" do
            game = BowlingGame.new
            20.times { game.roll(0) }
            game.score.should == 0
          end

          it "scores all 1s with 20" do
            game = BowlingGame.new
            20.times { game.roll(1) }
            game.score.should == 20
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Let there be let</h1>
      <p>We could move it into a <code>before</code> block&hellip;</p>
      <pre class="ruby">
        describe BowlingGame do
          before do
            @game = BowlingGame.new
          end

          it "scores all gutters with 0" do
            20.times { @game.roll(0) }
            @game.score.should == 0
          end

          it "scores all 1s with 20" do
            20.times { @game.roll(1) }
            @game.score.should == 20
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Let there be let</h1>
      <p>But using <code>let</code> is better.</p>
      <pre class="ruby">
        describe BowlingGame do
          let(:game) { BowlingGame.new }

          it "scores all gutters with 0" do
            20.times { game.roll(0) }
            game.score.should == 0
          end

          it "scores all 1s with 20" do
            20.times { game.roll(1) }
            game.score.should == 20
          end
        end
      </pre>
      <p>Variables assigned by <code>let</code> blocks are evaluated lazily,
      memoised on first use, and reset between examples.</p>
    </div>

    <div class="slide">
      <h1>Shared examples</h1>
      <p>Factor out common examples:</p>
      <pre class="ruby">
        shared_examples_for "a single-element array" do
          it { should_not be_empty }
          it { should have(1).element }
        end

        describe ["foo"] do
          it_behaves_like "a single-element array"
        end

        describe [42] do
          it_behaves_like "a single-element array"
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Shared examples</h1>
      <p>Variables can be set using a block:</p>
      <pre class="ruby">
        shared_examples_for "a collection object" do
          describe "&lt;&lt;" do
            it "adds objects to the end of the collection" do
              collection &lt;&lt; 1
              collection &lt;&lt; 2
              collection.to_a.should eq([1,2])
            end
          end
        end

        describe Array do
          it_behaves_like "a collection object" do
            let(:collection) { Array.new }
          end
        end

        describe Set do
          it_behaves_like "a collection object" do
            let(:collection) { Set.new }
          end
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Simple stub</h2>
      <p>A <em>double</em> is the generic term for mocks and stubs.</p>
      <pre class="ruby">
        foo = double :foo, :size =&gt; 3, :to_s =&gt; "Foo"
                   # ^^^^ foo is just a label
        foo.size
          # =&gt; 3
        foo.to_s
          # =&gt; "Foo"
        foo.upcase
          #  =&gt; RSpec::Mocks::MockExpectationError: Double "foo"
          #     received unexpected message :upcase with (no args)
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Stubbing methods</h2>
      <p>You can stub methods on doubles, or real objects or classes</p>
      <pre class="ruby">
        obj.stub(:valid?).and_return true

        User.stub(:find).with(user_id).and_return user
      </pre>
      <p>Dynamic return value with a block:</p>
      <pre class="ruby">
        obj.stub(:+) do |arg|
          obj + arg
        end
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Stubbing methods</h2>
      <p>Successive calls can return different values:</p>
      <pre class="ruby">
        foo.stub(:bar).and_return 1, 2, 3

        foo.bar
          # =&gt; 1
        foo.bar
          # =&gt; 2
        foo.bar
          # =&gt; 3
        foo.bar
          # =&gt; 3
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Null object</h2>
      <p>If you want your double to respond to any message:</p>
      <pre class="ruby">
        foo = double(:foo, :size =&gt; 3).as_null_object

        foo.upcase
          # => foo (returns self for unstubbed methods)
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Stubbing a method chain</h2>
      <p>Often indicates law of demeter violations, but is useful for cases like named scopes, eg:</p>
      <pre class="ruby">
        Article.recent.published
      </pre>
      <p>You could use multiple doubles:</p>
      <pre class="ruby">
        Article.stub(:recent).and_return double(:published =&gt; articles)
      </pre>
      <p>But it&rsquo;s easier to stub the whole chain at once:</p>
      <pre class="ruby">
        Article.stub_chain(:recent, :published).and_return articles

        Article.stub_chain("recent.published").and_return articles
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Expecting method calls</h2>
      <pre class="ruby">
        describe "Form" do
          let (:model) { double :model }
          let (:form) { Form.new model }

          context "when submitted" do
            it "saves the model" do
              model.should_receive(:save)
              form.submit
            end
          end
        end
      </pre>
      <hr />
      <pre>
        Failures:

          1) Form when submitted saves the model
             <span style="color:red">Failure/Error: model.should_receive(:save)
               (Double :model).save(any args)
                   expected: 1 time
                   received: 0 times</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Expecting calls with arguments</h2>
      <pre class="ruby">
        describe "Form" do
          let (:logger) { double :logger }
          let (:form) { Form.new logger }

          context "when submitted" do
            it "logs the event" do
              logger.should_receive(:info).with "Form submitted"
              form.submit
            end
          end
        end
      </pre>
      <hr />
      <pre>
        Failures:

          1) Form when submitted logs the event
             <span style="color:red">Failure/Error: @logger.info "Form was submitted"
               Double :logger received :info with unexpected arguments
                 expected: ("Form submitted")
                      got: ("Form was submitted")</span>
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>More mockery</h2>
      <p>You can specify call counts:</p>
      <pre class="ruby">
        foo.should_receive(:bar).once
        foo.should_receive(:bar).at_least(3).times
      </pre>
      <p>Arguments can be less strict:</p>
      <pre class="ruby">
        foo.should_receive(:bar).with(anything(), an_instance_of(String))
        foo.should_receive(:bar).with(hash_including(:a =&gt; 1))
        foo.should_receive(:bar).with(/^[a-z]*$/)
      </pre>
      <p>Mock methods can return values just like stubs:</p>
      <pre class="ruby">
        foo.should_receive(:bar).and_return "baz"
      </pre>
    </div>

    <div class="slide">
      <h1>Mocks and stubs</h1>
      <h2>Method order</h2>
      <p>Occasionally you need methods to be called in the right order:</p>
      <pre class="ruby">
        it "logs the event" do
          logger.should_receive(:info).with(form.id).ordered
          logger.should_receive(:info).with("Form submitted").ordered
          form.submit
        end
      </pre>
      <hr />
      <pre>
        Failures:

          1) Form when submitted logs the event
             <span style="color:red">Failure/Error: @logger.info "Form submitted"
               Double :logger received :info out of order</span>
      </pre>
    </div>

    <!--
      Things still to cover:

      rails
        http://relishapp.com/rspec/rspec-rails
        spec_helper
        spec/support
        model/controller/view/helper specs
        adding methods to controller etc
        migrating from test/unit
          http://blog.davidchelimsky.net/2009/2/2/rspec-works-with-test-unit/
    -->
  </body>
</html>
